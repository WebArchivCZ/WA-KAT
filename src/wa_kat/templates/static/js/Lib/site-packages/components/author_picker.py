#! /usr/bin/env python
# -*- coding: utf-8 -*-
#
# Interpreter version: python 2.7
#
# Imports =====================================================================
import json

from browser import html
from browser import document

from browser import alert  # TODO: Remove

from .shared import make_request
from .shared import func_on_enter


# Functions & classes =========================================================
class AuthorPicker(object):
    original_author_el = document["author"]

    div_el = document["author_picker"]  # whole <div>
    input_el = document["author_input"]  # <input> for author's name
    search_btn_el = document["search_author"]  # trigger the search of author
    select_el = document["author_select"]  # <select> element with authors
    storno_btn_el = document["storno_author"]  # used to storno the picking
    pick_btn_el = document["pick_author"]  # used to accept the selected author
    black_overlay_el = document["black_overlay"]

    picked_code = None
    code_to_name = {}

    @classmethod
    def show(cls):
        cls.div_el.style.display = "block"
        cls.black_overlay_el.style.display = "block"
        cls.black_overlay_el.bind("click", lambda x: cls.hide())
        cls.hide_errors()

    @classmethod
    def hide(cls):
        cls.div_el.style.display = "none"
        cls.black_overlay_el.style.display = "none"

    @classmethod
    def hide_errors(cls):
        cls.select_el.style.border = "0"
        cls.input_el.style.border = "0"

    @classmethod
    def _pick_selected_option(cls):
        for option in cls.select_el:
            # if the select is empty
            if not hasattr(option, "selected"):
                return None

            if option.selected:
                return option.value

        return None

    @classmethod
    def on_pick_button_pressed(cls, ev):
        cls.hide_errors()

        selected = cls._pick_selected_option()
        if not selected:
            cls.select_el.style.border = "2px solid red"
            return

        cls.picked_code = selected
        cls.original_author_el.value = cls.code_to_name[selected]
        cls.hide()

    @classmethod
    def set_select(cls, authors):
        """
        Put data into ``<select>`` element.

        Args:
            authors (dict): Dictionary with author informations returned from
                aleph REST API. Format:
                ``{"name": .., "code": .., "linked_forms": ["..",]}``.
        """
        cls.select_el.html = ""

        if not authors:
            cls.select_el.disabled = True
            cls.select_el <= html.OPTION("Nic nenalezeno!")
            return

        cls.select_el.disabled = False
        for author_dict in authors:
            name = author_dict.get("name")
            code = author_dict.get("code")
            is_corporation = author_dict.get("is_corporation")
            linked_forms = author_dict.get("linked_forms", []) or []

            if not (name and code):
                continue

            type_descriptor = ["osoba", "korporace"]

            alt_names = "%s [%s]" % (name, type_descriptor[is_corporation])
            if linked_forms:
                alt_names += " (" + ", ".join(linked_forms) + ")"

            cls.code_to_name[code] = author_dict
            cls.select_el <= html.OPTION(alt_names, value=code)

    @classmethod
    def bind(cls):
        document["show_author_picker"].bind("click", lambda x: cls.show())

        cls.storno_btn_el.bind("click", lambda x: cls.hide())
        cls.pick_btn_el.bind("click", cls.on_pick_button_pressed)

    @classmethod
    def __get__(cls, obj, objtype):
        return cls.code_to_name[cls.picked_code]

    @classmethod
    def __set__(cls, obj, value):
        code = value["code"]
        assert "name" in value
        cls.code_to_name[code] = value

    @classmethod
    def validate(cls):
        if not cls.picked_code:
            cls.original_author_el.style.border = "2px solid red"
            return False

        cls.original_author_el.style.border = "0"
        return True


class AuthorPickerAdapter(AuthorPicker):
    """
    Adapter of the :class:`AuthorPicker` to aleph REST API.
    """
    @classmethod
    def on_complete(cls, req):
        # handle http errors
        if not (req.status == 200 or req.status == 0):
            alert(req.text)  # better handling
            return

        cls.set_select(json.loads(req.text))

    @classmethod
    def start(cls, ev):
        # somehow the first call doesn't stop the propagation
        ev.stopPropagation()
        ev.preventDefault()

        # make sure, that `author` was filled
        author = cls.input_el.value.strip()
        if not author:
            cls.input_el.style.border = "2px solid red"
            return

        cls.hide_errors()

        make_request(
            url="/api_v1/aleph/authors_by_name",
            data={"name": author},
            on_complete=cls.on_complete
        )

    @classmethod
    def bind(cls):
        super(cls, cls).bind()

        cls.search_btn_el.bind("click", cls.start)
        cls.input_el.bind("keypress", func_on_enter(cls.start))


AuthorPickerAdapter.bind()
